

## 适配器模式
适配器模式Adapter 是⼀种结构型设计模式，它可以将⼀个类的接⼝转换成客户希望的另⼀个接⼝，主要⽬的是
充当两个不同接⼝之间的桥梁，使得原本接⼝不兼容的类能够⼀起⼯作。

⽬标接⼝Target : 客户端希望使⽤的接⼝  
适配器类Adapter : 实现客户端使⽤的⽬标接⼝，持有⼀个需要适配的类实例。  
被适配者Adaptee : 需要被适配的类  

例子：
生活中：充电从220v - 100v, 在国外需要一个插头适配器转化成220v  
spring: Spring MVC中， HandlerAdapter 接⼝是适配器模式的⼀种应⽤。它负责将处理器（Handler）适配到框架
中，使得不同类型的处理器能够统⼀处理请


## 代理模式
代理模式Proxy Pattern 是⼀种结构型设计模式，⽤于控制对其他对象的访问。  
在代理模式中，允许⼀个对象（代理）充当另⼀个对象（真实对象）的接⼝，以控制对这个对象的访问。通常⽤于
在访问某个对象时引⼊⼀些间接层(中介的作⽤)，这样可以在访问对象时添加额外的控制逻辑，⽐如限制访问权
限，延迟加载。

Subject（抽象主题）： 抽象类，通过接⼝或抽象类声明真实主题和代理对象实现的业务⽅法。  
RealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。  
Proxy（代理）：包含⼀个引⽤，该引⽤可以是RealSubject的实例，控制对RealSubject的访问，并可能负责
创建和删除RealSubject的实例。

Spring 框架的 AOP 模块使⽤了代理模式来实现切⾯编程。通过代理，Spring 能够在⽬标对象的⽅法执⾏
前、执⾏后或抛出异常时插⼊切⾯逻辑，⽽不需要修改原始代码。
Java 提供了动态代理机制，允许在运⾏时⽣成代理类。

## 装饰模式
通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，⼦类越多，装饰模式（ Decorator Pattern , 结
构型设计模式）可以在不定义⼦类的情况下动态的给对象添加⼀些额外的功能。具体的做法是将原始对象放⼊包含
⾏为的特殊封装类(装饰类)，从⽽为原始对象动态添加新的⾏为，⽽⽆需修改其代码。

组件Component ：通常是抽象类或者接⼝，是具体组件和装饰者的⽗类，定义了具体组件需要实现的⽅法，⽐如说我们定义Coffee 为组件。  
具体组件ConcreteComponent : 实现了Component接⼝的具体类，是被装饰的对象。  
装饰类Decorator : ⼀个抽象类，给具体组件添加功能，但是具体的功能由其⼦类具体装饰者完成，持有⼀个指向Component对象的引⽤。  
具体装饰类ConcreteDecorator : 扩展Decorator类，负责向Component对象添加新的⾏为，加⽜奶的咖啡是⼀个具体装饰类，加糖的咖啡也是⼀个具体装饰类。

装饰模式通常在以下⼏种情况使⽤：
- 当需要给⼀个现有类添加附加功能，但由于某些原因不能使⽤继承来⽣成⼦类进⾏扩充时，可以使⽤装饰模
式。
- 动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使⽤装饰模式。

在Java的I/O库中，装饰者模式被⼴泛⽤于增强I/O流的功能。例如， BufferedInputStream 和
BufferedOutputStream 这两个类提供了缓冲区的⽀持，通过在底层的输⼊流和输出流上添加缓冲区，提⾼了读
写的效率，它们都是InputStream 和OutputStream 的装饰器。BufferedReader 和BufferedWriter 这两个类
与BufferedInputStream 和BufferedOutputStream 类似，提供了字符流的缓冲功能，是Reader和Writer的装
饰者。

> 装饰模式适用于需要动态地给对象添加额外功能的情况，而且不希望通过生成子类来实现这些功能扩展。
代理模式适用于需要在访问对象时控制访问的情况，比如延迟加载、访问控制、日志记录等。

## 外观模式（门面模式）
外观模式Facade Pattern , 也被称为“⻔⾯模式”，是⼀种结构型设计模式，外观模式定义了⼀个⾼层接⼝，这个
接⼝使得⼦系统更容易使⽤，同时也隐藏了⼦系统的复杂性。   
⻔⾯模式可以将⼦系统关在“⻔⾥”隐藏起来，客户端只需要通过外观接⼝与外观对象进⾏交互，⽽不需要直
接和多个⼦系统交互，⽆论⼦系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。

举个例⼦，假设你正在编写的⼀个模块⽤来处理⽂件读取、解析、存储，我们可以将这个过程拆成三部分，然后创
建⼀个外观类，将⽂件系统操作、数据解析和存储操作封装在外观类中，为客户端提供⼀个简化的接⼝，如果后续
需要修改⽂件处理的流程或替换底层⼦系统，也只需在外观类中进⾏调整，不会影响客户端代码。

外观类：对外提供⼀个统⼀的⾼层次接⼝，使复杂的⼦系统变得更易使⽤。  
⼦系统类：实现⼦系统的功能，处理外观类指派的任务。

外观模式通过提供⼀个简化的接⼝，隐藏了系统的复杂性，降低了客户端和⼦系统之间的耦合度，客户端不需要了
解系统的内部实现细节，也不需要直接和多个⼦系统交互，只需要通过外观接⼝与外观对象进⾏交互。  
但是如果需要添加新的⼦系统或修改⼦系统的⾏为，就可能需要修改外观类，这违背了“开闭原则”。

Spring框架是⼀个⼴泛使⽤外观模式的例⼦。Spring框架提供了⼀个⼤量的功能，包括依赖注⼊、⾯向切⾯编
程（AOP）、事务管理等。Spring的ApplicationContext 可以看作是外观，隐藏了底层组件的复杂性，使
得开发者可以更轻松地使⽤Spring的功能。  
JDBC提供了⼀个⽤于与数据库交互的接⼝。DriverManager 类可以看作是外观，它简化了数据库驱动的加载
和连接的过程，隐藏了底层数据库连接的复杂性。

在Spring框架中，ApplicationContext就是一个典型的门面模式的应用。ApplicationContext是Spring的核心接口之一，它为应用程序提供了访问Spring容器的统一接口。通过ApplicationContext，开发者可以方便地访问Spring容器中的Bean、进行依赖注入、实现AOP等操作，而不需要了解Spring框架内部的复杂实现细节。

另外，Spring框架中的许多其他模块和组件，比如Spring MVC中的DispatcherServlet、Spring Data中的Repository接口等，也可以被视为门面模式的实现，它们为开发者提供了统一的接口来简化对框架的使用。