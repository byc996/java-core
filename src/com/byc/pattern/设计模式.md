

## 适配器模式
适配器模式Adapter 是⼀种结构型设计模式，它可以将⼀个类的接⼝转换成客户希望的另⼀个接⼝，主要⽬的是
充当两个不同接⼝之间的桥梁，使得原本接⼝不兼容的类能够⼀起⼯作。

⽬标接⼝Target : 客户端希望使⽤的接⼝  
适配器类Adapter : 实现客户端使⽤的⽬标接⼝，持有⼀个需要适配的类实例。  
被适配者Adaptee : 需要被适配的类  

例子：
生活中：充电从220v - 100v, 在国外需要一个插头适配器转化成220v  
spring: Spring MVC中， HandlerAdapter 接⼝是适配器模式的⼀种应⽤。它负责将处理器（Handler）适配到框架
中，使得不同类型的处理器能够统⼀处理请


## 代理模式
代理模式Proxy Pattern 是⼀种结构型设计模式，⽤于控制对其他对象的访问。  
在代理模式中，允许⼀个对象（代理）充当另⼀个对象（真实对象）的接⼝，以控制对这个对象的访问。通常⽤于
在访问某个对象时引⼊⼀些间接层(中介的作⽤)，这样可以在访问对象时添加额外的控制逻辑，⽐如限制访问权
限，延迟加载。

Subject（抽象主题）： 抽象类，通过接⼝或抽象类声明真实主题和代理对象实现的业务⽅法。  
RealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。  
Proxy（代理）：包含⼀个引⽤，该引⽤可以是RealSubject的实例，控制对RealSubject的访问，并可能负责
创建和删除RealSubject的实例。

Spring 框架的 AOP 模块使⽤了代理模式来实现切⾯编程。通过代理，Spring 能够在⽬标对象的⽅法执⾏
前、执⾏后或抛出异常时插⼊切⾯逻辑，⽽不需要修改原始代码。
Java 提供了动态代理机制，允许在运⾏时⽣成代理类。

## 装饰模式
通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，⼦类越多，装饰模式（ Decorator Pattern , 结
构型设计模式）可以在不定义⼦类的情况下动态的给对象添加⼀些额外的功能。具体的做法是将原始对象放⼊包含
⾏为的特殊封装类(装饰类)，从⽽为原始对象动态添加新的⾏为，⽽⽆需修改其代码。

组件Component ：通常是抽象类或者接⼝，是具体组件和装饰者的⽗类，定义了具体组件需要实现的⽅法，⽐如说我们定义Coffee 为组件。  
具体组件ConcreteComponent : 实现了Component接⼝的具体类，是被装饰的对象。  
装饰类Decorator : ⼀个抽象类，给具体组件添加功能，但是具体的功能由其⼦类具体装饰者完成，持有⼀个指向Component对象的引⽤。  
具体装饰类ConcreteDecorator : 扩展Decorator类，负责向Component对象添加新的⾏为，加⽜奶的咖啡是⼀个具体装饰类，加糖的咖啡也是⼀个具体装饰类。

装饰模式通常在以下⼏种情况使⽤：
- 当需要给⼀个现有类添加附加功能，但由于某些原因不能使⽤继承来⽣成⼦类进⾏扩充时，可以使⽤装饰模
式。
- 动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使⽤装饰模式。

在Java的I/O库中，装饰者模式被⼴泛⽤于增强I/O流的功能。例如， BufferedInputStream 和
BufferedOutputStream 这两个类提供了缓冲区的⽀持，通过在底层的输⼊流和输出流上添加缓冲区，提⾼了读
写的效率，它们都是InputStream 和OutputStream 的装饰器。BufferedReader 和BufferedWriter 这两个类
与BufferedInputStream 和BufferedOutputStream 类似，提供了字符流的缓冲功能，是Reader和Writer的装
饰者。

> 装饰模式适用于需要动态地给对象添加额外功能的情况，而且不希望通过生成子类来实现这些功能扩展。
代理模式适用于需要在访问对象时控制访问的情况，比如延迟加载、访问控制、日志记录等。

## 外观模式（门面模式）
外观模式Facade Pattern , 也被称为“⻔⾯模式”，是⼀种结构型设计模式，外观模式定义了⼀个⾼层接⼝，这个
接⼝使得⼦系统更容易使⽤，同时也隐藏了⼦系统的复杂性。   
⻔⾯模式可以将⼦系统关在“⻔⾥”隐藏起来，客户端只需要通过外观接⼝与外观对象进⾏交互，⽽不需要直
接和多个⼦系统交互，⽆论⼦系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。

举个例⼦，假设你正在编写的⼀个模块⽤来处理⽂件读取、解析、存储，我们可以将这个过程拆成三部分，然后创
建⼀个外观类，将⽂件系统操作、数据解析和存储操作封装在外观类中，为客户端提供⼀个简化的接⼝，如果后续
需要修改⽂件处理的流程或替换底层⼦系统，也只需在外观类中进⾏调整，不会影响客户端代码。

外观类：对外提供⼀个统⼀的⾼层次接⼝，使复杂的⼦系统变得更易使⽤。  
⼦系统类：实现⼦系统的功能，处理外观类指派的任务。

外观模式通过提供⼀个简化的接⼝，隐藏了系统的复杂性，降低了客户端和⼦系统之间的耦合度，客户端不需要了
解系统的内部实现细节，也不需要直接和多个⼦系统交互，只需要通过外观接⼝与外观对象进⾏交互。  
但是如果需要添加新的⼦系统或修改⼦系统的⾏为，就可能需要修改外观类，这违背了“开闭原则”。

Spring框架是⼀个⼴泛使⽤外观模式的例⼦。Spring框架提供了⼀个⼤量的功能，包括依赖注⼊、⾯向切⾯编
程（AOP）、事务管理等。Spring的ApplicationContext 可以看作是外观，隐藏了底层组件的复杂性，使
得开发者可以更轻松地使⽤Spring的功能。  
JDBC提供了⼀个⽤于与数据库交互的接⼝。DriverManager 类可以看作是外观，它简化了数据库驱动的加载
和连接的过程，隐藏了底层数据库连接的复杂性。

在Spring框架中，ApplicationContext就是一个典型的门面模式的应用。ApplicationContext是Spring的核心接口之一，它为应用程序提供了访问Spring容器的统一接口。通过ApplicationContext，开发者可以方便地访问Spring容器中的Bean、进行依赖注入、实现AOP等操作，而不需要了解Spring框架内部的复杂实现细节。

另外，Spring框架中的许多其他模块和组件，比如Spring MVC中的DispatcherServlet、Spring Data中的Repository接口等，也可以被视为门面模式的实现，它们为开发者提供了统一的接口来简化对框架的使用。

## 桥接模式

桥接模式（Bridge Pattern）是一种结构型设计模式，它旨在将抽象部分与其实现部分分离，从而使它们可以独立变化。桥接模式通过使用组合关系而不是继承关系来实现这种分离。

在桥接模式中，存在两个独立变化的维度，其中一个维度位于抽象层，另一个维度位于实现层。通过桥接模式，可以将抽象层和实现层分别维护，使得它们可以独立地扩展和变化，而不会相互影响。

抽象类（Abstraction）：定义抽象类的接口，维护一个指向实现类的引用。  
扩展抽象类（RefinedAbstraction）：对抽象类进行扩展，可以添加额外的功能。  
实现接口（Implementor）：定义实现类的接口，提供基本的操作。  
具体实现类（ConcreteImplementor）：实现实现接口定义的操作。  

桥接模式在⽇常开发中使⽤的并不是特别多，通常在以下情况下使⽤：
- 当⼀个类存在两个独⽴变化的维度，⽽且这两个维度都需要进⾏扩展时，使⽤桥接模式可以使它们独⽴变化， 减少耦合。
- 不希望使⽤继承，或继承导致类爆炸性增⻓

总体⽽⾔，桥接模式适⽤于那些有多个独⽴变化维度、需要灵活扩展的系统。

## 组合模式
组合模式是⼀种结构型设计模式，它将对象组合成树状结构来表示“部分-整体”的层次关系。组合模式使得客户端可
以统⼀处理单个对象和对象的组合，⽽⽆需区分它们的具体类型。

Component 组件： 组合模式的“根节点”，定义组合中所有对象的通⽤接⼝，可以是抽象类或接⼝。该类中定
义了⼦类的共性内容。  
Leaf 叶⼦：实现了Component接⼝的叶⼦节点，表示组合中的叶⼦对象，叶⼦节点没有⼦节点。  
Composite 合成： 作⽤是存储⼦部件，并且在Composite中实现了对⼦部件的相关操作，⽐如添加、删除、
获取⼦组件等。

组合模式可以使得客户端可以统⼀处理单个对象和组合对象，⽆需区分它们之间的差异，⽐如在图形编辑器中，图
形对象可以是简单的线、圆形，也可以是复杂的组合图形，这个时候可以对组合节点添加统⼀的操作。  
总的来说，组合模式适⽤于任何需要构建具有部分-整体层次结构的场景，⽐如组织架构管理、⽂件系统的⽂件和
⽂件夹组织等

## 享元模式
享元模式是⼀种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下⽂使⽤，⽽不必在每个
上下⽂中都创建新的对象。  
想要了解享元模式，就必须要区分什么是内部状态，什么是外部状态。
- 内部状态是指那些可以被多个对象共享的状态，它存储在享元对象内部，并且对于所有享元对象都是相同的，
这部分状态通常是不变的。
- ⽽外部状态是享元对象依赖的、可能变化的部分。这部分状态不存储在享元对象内部，⽽是在使⽤享元对象时
  通过参数传递给对象。

举个例⼦，图书馆中有很多相同的书籍，但每本书都可以被多个⼈借阅，图书馆⾥的书就是内部状态，⼈就是外部状态。

享元接⼝Flyweight : 所有具体享元类的共享接⼝，通常包含对外部状态的操作。  
具体享元类ConcreteFlyweight : 继承Flyweight 类或实现享元接⼝，包含内部状态。  
享元⼯⼚类FlyweightFactory : 创建并管理享元对象，当⽤户请求时，提供已创建的实例或者创建⼀个。  
客户端Client : 维护外部状态，在使⽤享元对象时，将外部状态传递给享元对象。

使⽤享元模式的关键在于包含⼤量相似对象，并且这些对象的内部状态可以共享。具体的应⽤场景包括⽂本编辑
器，图形编辑器，游戏中的⻆⾊创建，这些对象的内部状态⽐较固定(外观，技能，形状)，但是外部状态变化⽐较
⼤时，可以使⽤。

比如线程池

## 观察者模式
观察者模式（发布-订阅模式）属于⾏为型模式，定义了⼀种⼀对多的依赖关系，让多个观察者对象同时监听⼀个
主题对象，当主题对象的状态发⽣变化时，所有依赖于它的观察者都得到通知并被⾃动更新。

观察者模式依赖两个模块：
- Subject (主题)：也就是被观察的对象，它可以维护⼀组观察者，当主题本身发⽣改变时就会通知观察者。
- Observer (观察者)：观察主题的对象，当“被观察”的主题发⽣变化时，观察者就会得到通知并执⾏相应的处
理。

主题Subject ， ⼀般会定义成⼀个接⼝，提供⽅法⽤于注册、删除和通知观察者，通常也包含⼀个状态，当
状态发⽣改变时，通知所有的观察者。  
观察者Observer : 观察者也需要实现⼀个接⼝，包含⼀个更新⽅法，在接收主题通知时执⾏对应的操作。  
具体主题ConcreteSubject : 主题的具体实现, 维护⼀个观察者列表，包含了观察者的注册、删除和通知⽅
法。  
具体观察者ConcreteObserver : 观察者接⼝的具体实现，每个具体观察者都注册到具体主题中，当主题状态
变化并通知到具体观察者，具体观察者进⾏处理。

观察者模式特别适⽤于⼀个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够⾃动更新的情
况。 ⽐如说在图形⽤户界⾯中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被
⼴泛应⽤于GUI框架，⽐如Java的Swing框架。

## 策略模式
策略模式是⼀种⾏为型设计模式，它定义了⼀系列算法（这些算法完成的是相同的⼯作，只是实现不同），并将每
个算法封装起来，使它们可以相互替换，⽽且算法的变化不会影响使⽤算法的客户。  
举个例⼦，电商⽹站对于商品的折扣策略有不同的算法，⽐如新⽤户满减优惠，不同等级会员的打折情况不同，这
种情况下会产⽣⼤量的if-else语句, 并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。

策略类Strategy : 定义所有⽀持的算法的公共接⼝。  
具体策略类ConcreteStrategy : 实现了策略接⼝，提供具体的算法实现。  
上下⽂类Context : 包含⼀个策略实例，并在需要时调⽤策略对象的⽅法。

那什么时候可以考虑使⽤策略模式呢？  
- 当⼀个系统根据业务场景需要动态地在⼏种算法中选择⼀种时，可以使⽤策略模式。例如，根据⽤户的⾏为选择不同的计费策略。  
- 当代码中存在⼤量条件判断，条件判断的区别仅仅在于⾏为，也可以通过策略模式来消除这些条件语句。 

在已有的⼯具库中，Java 标准库中的 Comparator 接⼝就使⽤了策略模式，通过实现这个接⼝，可以创建不同的
⽐较器（指定不同的排序策略）来满⾜不同的排序需求。