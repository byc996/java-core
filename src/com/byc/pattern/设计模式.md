

## 适配器模式
适配器模式Adapter 是⼀种结构型设计模式，它可以将⼀个类的接⼝转换成客户希望的另⼀个接⼝，主要⽬的是
充当两个不同接⼝之间的桥梁，使得原本接⼝不兼容的类能够⼀起⼯作。

⽬标接⼝Target : 客户端希望使⽤的接⼝  
适配器类Adapter : 实现客户端使⽤的⽬标接⼝，持有⼀个需要适配的类实例。  
被适配者Adaptee : 需要被适配的类  

例子：
生活中：充电从220v - 100v, 在国外需要一个插头适配器转化成220v  
spring: Spring MVC中， HandlerAdapter 接⼝是适配器模式的⼀种应⽤。它负责将处理器（Handler）适配到框架
中，使得不同类型的处理器能够统⼀处理请


## 代理模式
代理模式Proxy Pattern 是⼀种结构型设计模式，⽤于控制对其他对象的访问。  
在代理模式中，允许⼀个对象（代理）充当另⼀个对象（真实对象）的接⼝，以控制对这个对象的访问。通常⽤于
在访问某个对象时引⼊⼀些间接层(中介的作⽤)，这样可以在访问对象时添加额外的控制逻辑，⽐如限制访问权
限，延迟加载。

Subject（抽象主题）： 抽象类，通过接⼝或抽象类声明真实主题和代理对象实现的业务⽅法。  
RealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。  
Proxy（代理）：包含⼀个引⽤，该引⽤可以是RealSubject的实例，控制对RealSubject的访问，并可能负责
创建和删除RealSubject的实例。

Spring 框架的 AOP 模块使⽤了代理模式来实现切⾯编程。通过代理，Spring 能够在⽬标对象的⽅法执⾏
前、执⾏后或抛出异常时插⼊切⾯逻辑，⽽不需要修改原始代码。
Java 提供了动态代理机制，允许在运⾏时⽣成代理类。

## 装饰模式
通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，⼦类越多，装饰模式（ Decorator Pattern , 结
构型设计模式）可以在不定义⼦类的情况下动态的给对象添加⼀些额外的功能。具体的做法是将原始对象放⼊包含
⾏为的特殊封装类(装饰类)，从⽽为原始对象动态添加新的⾏为，⽽⽆需修改其代码。

组件Component ：通常是抽象类或者接⼝，是具体组件和装饰者的⽗类，定义了具体组件需要实现的⽅法，⽐如说我们定义Coffee 为组件。  
具体组件ConcreteComponent : 实现了Component接⼝的具体类，是被装饰的对象。  
装饰类Decorator : ⼀个抽象类，给具体组件添加功能，但是具体的功能由其⼦类具体装饰者完成，持有⼀个指向Component对象的引⽤。  
具体装饰类ConcreteDecorator : 扩展Decorator类，负责向Component对象添加新的⾏为，加⽜奶的咖啡是⼀个具体装饰类，加糖的咖啡也是⼀个具体装饰类。

装饰模式通常在以下⼏种情况使⽤：
- 当需要给⼀个现有类添加附加功能，但由于某些原因不能使⽤继承来⽣成⼦类进⾏扩充时，可以使⽤装饰模
式。
- 动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使⽤装饰模式。

在Java的I/O库中，装饰者模式被⼴泛⽤于增强I/O流的功能。例如， BufferedInputStream 和
BufferedOutputStream 这两个类提供了缓冲区的⽀持，通过在底层的输⼊流和输出流上添加缓冲区，提⾼了读
写的效率，它们都是InputStream 和OutputStream 的装饰器。BufferedReader 和BufferedWriter 这两个类
与BufferedInputStream 和BufferedOutputStream 类似，提供了字符流的缓冲功能，是Reader和Writer的装
饰者。

> 装饰模式适用于需要动态地给对象添加额外功能的情况，而且不希望通过生成子类来实现这些功能扩展。
代理模式适用于需要在访问对象时控制访问的情况，比如延迟加载、访问控制、日志记录等。