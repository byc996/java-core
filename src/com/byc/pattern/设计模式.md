## 单例模式
单例模式是⼀种创建型设计模式， 它的核⼼思想是保证⼀个类只有⼀个实例，并提供⼀个全局访问点来访问这个实
例。
- 只有⼀个实例的意思是，在整个应⽤程序中，只存在该类的⼀个实例对象，⽽不是创建多个相同类型的对象。
- 全局访问点的意思是，为了让其他类能够获取到这个唯⼀实例，该类提供了⼀个全局访问点（通常是⼀个静态
⽅法），通过这个⽅法就能获得实例。

想要实现⼀个单例设计模式，必须遵循以下规则：
- 私有的构造函数：防⽌外部代码直接创建类的实例
- 私有的静态实例变量：保存该类的唯⼀实例
- 公有的静态⽅法：通过公有的静态⽅法来获取类的实例

单例模式的实现⽅式有多种，包括懒汉式、饿汉式等。  
饿汉式指的是在类加载时就已经完成了实例的创建，不管后⾯创建的实例有没有使⽤，先创建再说，所以叫做
“饿汉”。  
⽽懒汉式指的是只有在请求实例时才会创建，如果在⾸次请求时还没有创建，就创建⼀个新的实例，如果已经创
建，就返回已有的实例，意思就是需要使⽤了再创建，所以称为“懒汉”。  
在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的
问题，但是懒汉式中多个线程同时访问 getInstance() ⽅法，并且在同⼀时刻检测到实例没有被创建，就可能会
同时创建实例，从⽽导致多个实例被创建，这种情况下我们可以采⽤⼀些同步机制，例如使⽤互斥锁来确保在任何
时刻只有⼀个线程能够执⾏实例的创建。

说了这么多，那在什么场景下应该考虑使⽤单例设计模式呢？可以结合单例设计模式的优点来看。
1. 资源共享  
   多个模块共享某个资源的时候，可以使⽤单例模式，⽐如说应⽤程序需要⼀个全局的配置管理器来存储和管理配置
   信息、亦或是使⽤单例模式管理数据库连接池。
2. 只有⼀个实例  
   当系统中某个类只需要⼀个实例来协调⾏为的时候，可以考虑使⽤单例模式， ⽐如说管理应⽤程序中的缓存，确保
   只有⼀个缓存实例，避免重复的缓存创建和管理，或者使⽤单例模式来创建和管理线程池。
3. 懒加载  
   如果对象创建本身就⽐较消耗资源，⽽且可能在整个程序中都不⼀定会使⽤，可以使⽤单例模式实现懒加载。
   在许多流⾏的⼯具和库中，也都使⽤到了单例设计模式，⽐如Java中的Runtime 类就是⼀个经典的单例，表示程序
   的运⾏时环境。此外 Spring 框架中的应⽤上下⽂ ( ApplicationContext ) 也被设计为单例，以提供对应⽤程序中
   所有 bean 的集中式访问点。

## 适配器模式
适配器模式Adapter 是⼀种结构型设计模式，它可以将⼀个类的接⼝转换成客户希望的另⼀个接⼝，主要⽬的是
充当两个不同接⼝之间的桥梁，使得原本接⼝不兼容的类能够⼀起⼯作。

⽬标接⼝Target : 客户端希望使⽤的接⼝  
适配器类Adapter : 实现客户端使⽤的⽬标接⼝，持有⼀个需要适配的类实例。  
被适配者Adaptee : 需要被适配的类  

例子：
生活中：充电从220v - 100v, 在国外需要一个插头适配器转化成220v  
spring: Spring MVC中， HandlerAdapter 接⼝是适配器模式的⼀种应⽤。它负责将处理器（Handler）适配到框架
中，使得不同类型的处理器能够统⼀处理请


## 代理模式
代理模式Proxy Pattern 是⼀种结构型设计模式，⽤于控制对其他对象的访问。  
在代理模式中，允许⼀个对象（代理）充当另⼀个对象（真实对象）的接⼝，以控制对这个对象的访问。通常⽤于
在访问某个对象时引⼊⼀些间接层(中介的作⽤)，这样可以在访问对象时添加额外的控制逻辑，⽐如限制访问权
限，延迟加载。

Subject（抽象主题）： 抽象类，通过接⼝或抽象类声明真实主题和代理对象实现的业务⽅法。  
RealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。  
Proxy（代理）：包含⼀个引⽤，该引⽤可以是RealSubject的实例，控制对RealSubject的访问，并可能负责
创建和删除RealSubject的实例。

Spring 框架的 AOP 模块使⽤了代理模式来实现切⾯编程。通过代理，Spring 能够在⽬标对象的⽅法执⾏
前、执⾏后或抛出异常时插⼊切⾯逻辑，⽽不需要修改原始代码。
Java 提供了动态代理机制，允许在运⾏时⽣成代理类。

## 装饰模式
通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，⼦类越多，装饰模式（ Decorator Pattern , 结
构型设计模式）可以在不定义⼦类的情况下动态的给对象添加⼀些额外的功能。具体的做法是将原始对象放⼊包含
⾏为的特殊封装类(装饰类)，从⽽为原始对象动态添加新的⾏为，⽽⽆需修改其代码。

组件Component ：通常是抽象类或者接⼝，是具体组件和装饰者的⽗类，定义了具体组件需要实现的⽅法，⽐如说我们定义Coffee 为组件。  
具体组件ConcreteComponent : 实现了Component接⼝的具体类，是被装饰的对象。  
装饰类Decorator : ⼀个抽象类，给具体组件添加功能，但是具体的功能由其⼦类具体装饰者完成，持有⼀个指向Component对象的引⽤。  
具体装饰类ConcreteDecorator : 扩展Decorator类，负责向Component对象添加新的⾏为，加⽜奶的咖啡是⼀个具体装饰类，加糖的咖啡也是⼀个具体装饰类。

装饰模式通常在以下⼏种情况使⽤：
- 当需要给⼀个现有类添加附加功能，但由于某些原因不能使⽤继承来⽣成⼦类进⾏扩充时，可以使⽤装饰模
式。
- 动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使⽤装饰模式。

在Java的I/O库中，装饰者模式被⼴泛⽤于增强I/O流的功能。例如， BufferedInputStream 和
BufferedOutputStream 这两个类提供了缓冲区的⽀持，通过在底层的输⼊流和输出流上添加缓冲区，提⾼了读
写的效率，它们都是InputStream 和OutputStream 的装饰器。BufferedReader 和BufferedWriter 这两个类
与BufferedInputStream 和BufferedOutputStream 类似，提供了字符流的缓冲功能，是Reader和Writer的装
饰者。

> 装饰模式适用于需要动态地给对象添加额外功能的情况，而且不希望通过生成子类来实现这些功能扩展。
代理模式适用于需要在访问对象时控制访问的情况，比如延迟加载、访问控制、日志记录等。

## 外观模式（门面模式）
外观模式Facade Pattern , 也被称为“⻔⾯模式”，是⼀种结构型设计模式，外观模式定义了⼀个⾼层接⼝，这个
接⼝使得⼦系统更容易使⽤，同时也隐藏了⼦系统的复杂性。   
⻔⾯模式可以将⼦系统关在“⻔⾥”隐藏起来，客户端只需要通过外观接⼝与外观对象进⾏交互，⽽不需要直
接和多个⼦系统交互，⽆论⼦系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。

举个例⼦，假设你正在编写的⼀个模块⽤来处理⽂件读取、解析、存储，我们可以将这个过程拆成三部分，然后创
建⼀个外观类，将⽂件系统操作、数据解析和存储操作封装在外观类中，为客户端提供⼀个简化的接⼝，如果后续
需要修改⽂件处理的流程或替换底层⼦系统，也只需在外观类中进⾏调整，不会影响客户端代码。

外观类：对外提供⼀个统⼀的⾼层次接⼝，使复杂的⼦系统变得更易使⽤。  
⼦系统类：实现⼦系统的功能，处理外观类指派的任务。

外观模式通过提供⼀个简化的接⼝，隐藏了系统的复杂性，降低了客户端和⼦系统之间的耦合度，客户端不需要了
解系统的内部实现细节，也不需要直接和多个⼦系统交互，只需要通过外观接⼝与外观对象进⾏交互。  
但是如果需要添加新的⼦系统或修改⼦系统的⾏为，就可能需要修改外观类，这违背了“开闭原则”。

Spring框架是⼀个⼴泛使⽤外观模式的例⼦。Spring框架提供了⼀个⼤量的功能，包括依赖注⼊、⾯向切⾯编
程（AOP）、事务管理等。Spring的ApplicationContext 可以看作是外观，隐藏了底层组件的复杂性，使
得开发者可以更轻松地使⽤Spring的功能。  
JDBC提供了⼀个⽤于与数据库交互的接⼝。DriverManager 类可以看作是外观，它简化了数据库驱动的加载
和连接的过程，隐藏了底层数据库连接的复杂性。

在Spring框架中，ApplicationContext就是一个典型的门面模式的应用。ApplicationContext是Spring的核心接口之一，它为应用程序提供了访问Spring容器的统一接口。通过ApplicationContext，开发者可以方便地访问Spring容器中的Bean、进行依赖注入、实现AOP等操作，而不需要了解Spring框架内部的复杂实现细节。

另外，Spring框架中的许多其他模块和组件，比如Spring MVC中的DispatcherServlet、Spring Data中的Repository接口等，也可以被视为门面模式的实现，它们为开发者提供了统一的接口来简化对框架的使用。

## 桥接模式

桥接模式（Bridge Pattern）是一种结构型设计模式，它旨在将抽象部分与其实现部分分离，从而使它们可以独立变化。桥接模式通过使用组合关系而不是继承关系来实现这种分离。

在桥接模式中，存在两个独立变化的维度，其中一个维度位于抽象层，另一个维度位于实现层。通过桥接模式，可以将抽象层和实现层分别维护，使得它们可以独立地扩展和变化，而不会相互影响。

抽象类（Abstraction）：定义抽象类的接口，维护一个指向实现类的引用。  
扩展抽象类（RefinedAbstraction）：对抽象类进行扩展，可以添加额外的功能。  
实现接口（Implementor）：定义实现类的接口，提供基本的操作。  
具体实现类（ConcreteImplementor）：实现实现接口定义的操作。  

桥接模式在⽇常开发中使⽤的并不是特别多，通常在以下情况下使⽤：
- 当⼀个类存在两个独⽴变化的维度，⽽且这两个维度都需要进⾏扩展时，使⽤桥接模式可以使它们独⽴变化， 减少耦合。
- 不希望使⽤继承，或继承导致类爆炸性增⻓

总体⽽⾔，桥接模式适⽤于那些有多个独⽴变化维度、需要灵活扩展的系统。

## 组合模式
组合模式是⼀种结构型设计模式，它将对象组合成树状结构来表示“部分-整体”的层次关系。组合模式使得客户端可
以统⼀处理单个对象和对象的组合，⽽⽆需区分它们的具体类型。

Component 组件： 组合模式的“根节点”，定义组合中所有对象的通⽤接⼝，可以是抽象类或接⼝。该类中定
义了⼦类的共性内容。  
Leaf 叶⼦：实现了Component接⼝的叶⼦节点，表示组合中的叶⼦对象，叶⼦节点没有⼦节点。  
Composite 合成： 作⽤是存储⼦部件，并且在Composite中实现了对⼦部件的相关操作，⽐如添加、删除、
获取⼦组件等。

组合模式可以使得客户端可以统⼀处理单个对象和组合对象，⽆需区分它们之间的差异，⽐如在图形编辑器中，图
形对象可以是简单的线、圆形，也可以是复杂的组合图形，这个时候可以对组合节点添加统⼀的操作。  
总的来说，组合模式适⽤于任何需要构建具有部分-整体层次结构的场景，⽐如组织架构管理、⽂件系统的⽂件和
⽂件夹组织等

## 享元模式
享元模式是⼀种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下⽂使⽤，⽽不必在每个
上下⽂中都创建新的对象。  
想要了解享元模式，就必须要区分什么是内部状态，什么是外部状态。
- 内部状态是指那些可以被多个对象共享的状态，它存储在享元对象内部，并且对于所有享元对象都是相同的，
这部分状态通常是不变的。
- ⽽外部状态是享元对象依赖的、可能变化的部分。这部分状态不存储在享元对象内部，⽽是在使⽤享元对象时
  通过参数传递给对象。

举个例⼦，图书馆中有很多相同的书籍，但每本书都可以被多个⼈借阅，图书馆⾥的书就是内部状态，⼈就是外部状态。

享元接⼝Flyweight : 所有具体享元类的共享接⼝，通常包含对外部状态的操作。  
具体享元类ConcreteFlyweight : 继承Flyweight 类或实现享元接⼝，包含内部状态。  
享元⼯⼚类FlyweightFactory : 创建并管理享元对象，当⽤户请求时，提供已创建的实例或者创建⼀个。  
客户端Client : 维护外部状态，在使⽤享元对象时，将外部状态传递给享元对象。

使⽤享元模式的关键在于包含⼤量相似对象，并且这些对象的内部状态可以共享。具体的应⽤场景包括⽂本编辑
器，图形编辑器，游戏中的⻆⾊创建，这些对象的内部状态⽐较固定(外观，技能，形状)，但是外部状态变化⽐较
⼤时，可以使⽤。

比如线程池

## 观察者模式
观察者模式（发布-订阅模式）属于⾏为型模式，定义了⼀种⼀对多的依赖关系，让多个观察者对象同时监听⼀个
主题对象，当主题对象的状态发⽣变化时，所有依赖于它的观察者都得到通知并被⾃动更新。

观察者模式依赖两个模块：
- Subject (主题)：也就是被观察的对象，它可以维护⼀组观察者，当主题本身发⽣改变时就会通知观察者。
- Observer (观察者)：观察主题的对象，当“被观察”的主题发⽣变化时，观察者就会得到通知并执⾏相应的处
理。

主题Subject ， ⼀般会定义成⼀个接⼝，提供⽅法⽤于注册、删除和通知观察者，通常也包含⼀个状态，当
状态发⽣改变时，通知所有的观察者。  
观察者Observer : 观察者也需要实现⼀个接⼝，包含⼀个更新⽅法，在接收主题通知时执⾏对应的操作。  
具体主题ConcreteSubject : 主题的具体实现, 维护⼀个观察者列表，包含了观察者的注册、删除和通知⽅
法。  
具体观察者ConcreteObserver : 观察者接⼝的具体实现，每个具体观察者都注册到具体主题中，当主题状态
变化并通知到具体观察者，具体观察者进⾏处理。

观察者模式特别适⽤于⼀个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够⾃动更新的情
况。 ⽐如说在图形⽤户界⾯中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被
⼴泛应⽤于GUI框架，⽐如Java的Swing框架。

## 策略模式
策略模式是⼀种⾏为型设计模式，它定义了⼀系列算法（这些算法完成的是相同的⼯作，只是实现不同），并将每
个算法封装起来，使它们可以相互替换，⽽且算法的变化不会影响使⽤算法的客户。  
举个例⼦，电商⽹站对于商品的折扣策略有不同的算法，⽐如新⽤户满减优惠，不同等级会员的打折情况不同，这
种情况下会产⽣⼤量的if-else语句, 并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。

策略类Strategy : 定义所有⽀持的算法的公共接⼝。  
具体策略类ConcreteStrategy : 实现了策略接⼝，提供具体的算法实现。  
上下⽂类Context : 包含⼀个策略实例，并在需要时调⽤策略对象的⽅法。

那什么时候可以考虑使⽤策略模式呢？  
- 当⼀个系统根据业务场景需要动态地在⼏种算法中选择⼀种时，可以使⽤策略模式。例如，根据⽤户的⾏为选择不同的计费策略。  
- 当代码中存在⼤量条件判断，条件判断的区别仅仅在于⾏为，也可以通过策略模式来消除这些条件语句。 

在已有的⼯具库中，Java 标准库中的 Comparator 接⼝就使⽤了策略模式，通过实现这个接⼝，可以创建不同的
⽐较器（指定不同的排序策略）来满⾜不同的排序需求。

## 命令模式
命令模式是⼀种⾏为型设计模式，其允许将请求封装成⼀个对象(命令对象，包含执⾏操作所需的所有信息)，并将
命令对象按照⼀定的顺序存储在队列中，然后再逐⼀调⽤执⾏，这些命令也可以⽀持反向操作，进⾏撤销和重做。  
这样⼀来，发送者只需要触发命令就可以完成操作，不需要知道接受者的具体操作，从⽽实现两者间的解耦。  
举个现实中的应⽤场景，遥控器可以控制不同的设备，在命令模式中，可以假定每个按钮都是⼀个命令对象，包含
执⾏特定操作的命令，不同设备对同⼀命令的具体操作也不同，这样就可以⽅便的添加设备和命令对象。

命令接⼝Command ：接⼝或者抽象类，定义执⾏操作的接⼝。  
具体命令类ConcreteCommand : 实现命令接⼝，执⾏具体操作，在调⽤execute ⽅法时使“接收者对象”根据
命令完成具体的任务，⽐如遥控器中的“开机”，“关机”命令。  
接收者类Receiver : 接受并执⾏命令的对象，可以是任何对象，遥控器可以控制空调，也可以控制电视机，
电视机和空调负责执⾏具体操作，是接收者。  
调⽤者类Invoker : 发起请求的对象，有⼀个将命令作为参数传递的⽅法。它不关⼼命令的具体实现，只负
责调⽤命令对象的 execute() ⽅法来传递请求，在本例中，控制遥控器的“⼈”就是调⽤者。  
客户端：创建具体的命令对象和接收者对象，然后将它们组装起来。

命令模式在需要将请求封装成对象、⽀持撤销和重做、设计命令队列等情况下，都是⼀个有效的设计模式。
- 撤销操作： 需要⽀持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。
- 队列请求： 命令模式可以将请求排队，形成⼀个命令队列，依次执⾏命令。
- 可扩展性： 可以很容易地添加新的命令类和接收者类，⽽不影响现有的代码。新增命令不需要修改现有代
码，符合开闭原则。  

但是对于每个命令，都会有⼀个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。  
命令模式同样有着很多现实场景的应⽤，⽐如Git中的很多操作，如提交（commit）、合并（merge）等，都可以
看作是命令模式的应⽤，⽤户通过执⾏相应的命令来操作版本库。Java的GUI编程中，很多事件处理机制也都使⽤
了命令模式。例如，每个按钮都有⼀个关联的 Action ，它代表⼀个命令，按钮的点击触发 Action 的执⾏。

## 中介者模式
中介者模式（Mediator Pattern）也被称为调停者模式，是⼀种⾏为型设计模式，它通过⼀个中介对象来封装⼀组
对象之间的交互，从⽽使这些对象不需要直接相互引⽤。这样可以降低对象之间的耦合度，使系统更容易维护和扩
展。

抽象中介者（Mediator）： 定义中介者的接⼝，⽤于各个具体同事对象之间的通信。  
具体中介者（Concrete Mediator）： 实现抽象中介者接⼝，负责协调各个具体同事对象的交互关系，它需
要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。  
抽象同事类（Colleague）： 定义同事类的接⼝，维护⼀个对中介者对象的引⽤，⽤于通信。  
具体同事类（Concrete Colleague）： 实现抽象同事类接⼝，每个具体同事类只知道⾃⼰的⾏为，⽽不了解
其他同事类的情况，因为它们都需要与中介者通信，通过中介者协调与其他同事对象的交互。

中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进⾏通信，简化了系统的复杂度，也降低了各对
象之间的耦合度，但是这也会使得中介者对象变得过于庞⼤和复杂，如果中介者对象出现问题，整个系统可能会受
到影响。  
中介者模式适⽤于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进⾏灵活的通信时使⽤，可以
使得问题简化

## 备忘录模式
备忘录模式（Memento Pattern）是⼀种⾏为型设计模式，它允许在不暴露对象实现的情况下捕获对象的内部状态
并在对象之外保存这个状态，以便稍后可以将其还原到先前的状态。

备忘录模式包括以下⼏个重要⻆⾊：  
- 发起⼈Originator ： 需要还原状态的那个对象，负责创建⼀个【备忘录】，并使⽤备忘录记录当前时刻的
内部状态。
- 备忘录Memento : 存储发起⼈对象的内部状态，它可以包含发起⼈的部分或全部状态信息，但是对外部是不
可⻅的，只有发起⼈能够访问备忘录对象的状态。
> 备忘录有两个接⼝，发起⼈能够通过宽接⼝访问数据，管理者只能看到窄接⼝，并将备忘录传递给其他对
象。
- 管理者Caretaker : 负责存储备忘录对象，但并不了解其内部结构，管理者可以存储多个备忘录对象。
- 客户端：在需要恢复状态时，客户端可以从管理者那⾥获取备忘录对象，并将其传递给发起⼈进⾏状态的恢
复。

备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起⼈，实现“备份”，不过
备份对象往往会消耗较多的内存，资源消耗增加。  
备忘录模式常常⽤来实现撤销和重做功能，⽐如在Java Swing GUI编程中， javax.swing.undo 包中的撤销
（undo）和重做（redo）机制使⽤了备忘录模式。UndoManager 和UndoableEdit 接⼝是与备忘录模式相关的主
要类和接⼝。

## 模板⽅法模式
模板⽅法模式（Template Method Pattern）是⼀种⾏为型设计模式, 它定义了⼀个算法的⻣架，将⼀些步骤的实
现延迟到⼦类。模板⽅法模式使得⼦类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。  

模板类AbstractClass ：由⼀个模板⽅法和若⼲个基本⽅法构成，模板⽅法定义了逻辑的⻣架，按照顺序调
⽤包含的基本⽅法，基本⽅法通常是⼀些抽象⽅法，这些⽅法由⼦类去实现。基本⽅法还包含⼀些具体⽅法，
它们是算法的⼀部分但已经有默认实现，在具体⼦类中可以继承或者重写。  
具体类ConcreteClass ：继承⾃模板类，实现了在模板类中定义的抽象⽅法，以完成算法中特定步骤的具体
实现。

模板⽅法模式将算法的不变部分被封装在模板⽅法中，⽽可变部分算法由⼦类继承实现，这样做可以很好的提⾼代
码的复⽤性，但是当算法的框架发⽣变化时，可能需要修改模板类，这也会影响到所有的⼦类。  
总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板⽅法模式
来处理。在已有的⼯具和库中， Spring框架中的JdbcTemplate 类使⽤了模板⽅法模式，其中定义了⼀些执⾏数
据库操作的模板⽅法，具体的数据库操作由回调函数提供。⽽在Java的JDK源码中， AbstractList 类也使⽤了模
板⽅法模式，它提供了⼀些通⽤的⽅法，其中包括⼀些模板⽅法。具体的列表操作由⼦类实现。

## 迭代器模式
迭代器模式是⼀种⾏为设计模式，是⼀种使⽤频率⾮常⾼的设计模式，在各个语⾔中都有应⽤，其主要⽬的是提供
⼀种统⼀的⽅式来访问⼀个聚合对象中的各个元素，⽽不需要暴露该对象的内部表示。通过迭代器，客户端可以顺
序访问聚合对象的元素，⽽⽆需了解底层数据结构。  
迭代器模式应⽤⼴泛，但是⼤多数语⾔都已经内置了迭代器接⼝，不需要⾃⼰实现。

迭代器接⼝Iterator ：定义访问和遍历元素的接⼝, 通常会包括hasNext() ⽅法⽤于检查是否还有下⼀个
元素，以及next() ⽅法⽤于获取下⼀个元素。有的还会实现获取第⼀个元素以及获取当前元素的⽅法。  
具体迭代器ConcreateIterator ：实现迭代器接⼝，实现遍历逻辑对聚合对象进⾏遍历。  
抽象聚合类：定义了创建迭代器的接⼝，包括⼀个createIterator ⽅法⽤于创建⼀个迭代器对象。  
具体聚合类：实现在抽象聚合类中声明的createIterator() ⽅法，返回⼀个与具体聚合对应的具体迭代器

迭代器模式是⼀种通⽤的设计模式，其封装性强，简化了客户端代码，客户端不需要知道集合的内部结构，只需要
关⼼迭代器和迭代接⼝就可以完成元素的访问。但是引⼊迭代器模式会增加额外的类，每增加⼀个集合类，都需要
增加该集合对应的迭代器，这也会使得代码结构变得更加复杂。  
许多编程语⾔和框架都使⽤了这个模式提供⼀致的遍历和访问集合元素的机制。下⾯是⼏种常⻅语⾔迭代器模式的
实现。  
Java语⾔：集合类（如ArrayList、LinkedList), 通过Iterator 接⼝，可以遍历集合中的元素。

## 状态模式
状态模式（State Pattern）是⼀种⾏为型设计模式，它适⽤于⼀个对象在在不同的状态下有不同的⾏为时，⽐如说
电灯的开、关、闪烁是不停的状态，状态不同时，对应的⾏为也不同，在没有状态模式的情况下，为了添加新的状
态或修改现有的状态，往往需要修改已有的代码，这违背了开闭原则，⽽且如果对象的状态切换逻辑和各个状态的
⾏为都在同⼀个类中实现，就可能导致该类的职责过重，不符合单⼀职责原则。  
⽽状态模式将每个状态的⾏为封装在⼀个具体状态类中，使得每个状态类相对独⽴，并将对象在不同状态下的⾏为
进⾏委托，从⽽使得对象的状态可以在运⾏时动态改变，每个状态的实现也不会影响其他状态。

State （状态）： 定义⼀个接⼝，⽤于封装与Context的⼀个特定状态相关的⾏为。  
ConcreteState （具体状态）： 负责处理Context在状态改变时的⾏为, 每⼀个具体状态⼦类实现⼀个
与Context 的⼀个状态相关的⾏为。  
Context （上下⽂）: 维护⼀个具体状态⼦类的实例，这个实例定义当前的状态。  

状态模式将每个状态的实现都封装在⼀个类中，每个状态类的实现相对独⽴，使得添加新状态或修改现有状态变得
更加容易，避免了使⽤⼤量的条件语句来控制对象的⾏为。但是如果状态过多，会导致类的数量增加，可能会使得
代码结构复杂。  
总的来说，状态模式适⽤于有限状态机的场景，其中对象的⾏为在运⾏时可以根据内部状态的改变⽽改变，在游戏
开发中，Unity3D 的 Animator 控制器就是⼀个状态机。它允许开发⼈员定义不同的状态（动画状态），并通过状
态转换来实现⻆⾊的动画控制和⾏为切换。

## 责任链模式
责任链模式是⼀种⾏为型设计模式，它允许你构建⼀个对象链，让请求从链的⼀端进⼊，然后沿着链上的对象依次
处理，直到链上的某个对象能够处理该请求为⽌。  
职责链上的处理者就是⼀个对象，可以对请求进⾏处理或者将请求转发给下⼀个节点，这个场景在⽣活中很常⻅，
就是⼀个逐层向上递交的过程，最终的请求要么被处理者所处理，要么处理不了，这也因此可能导致请求⽆法被处
理。

责任链模式包括以下⼏个基本结构：
1. 处理者Handler ：定义⼀个处理请求的接⼝，包含⼀个处理请求的抽象⽅法和⼀个指向下⼀个处理者的链
   接。
2. 具体处理者ConcreteHandler : 实现处理请求的⽅法，并判断能否处理请求，如果能够处理请求则进⾏处
   理，否则将请求传递给下⼀个处理者。
3. 客户端：创建并组装处理者对象链，并将请求发送到链上的第⼀个处理者。

责任链模式具有下⾯⼏个优点：
- 降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与⾃⼰相关的请求，客户端不需要 知道具体是哪个处理者处理请求。
- 增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满⾜不同需求。

但是由于⼀个请求可能会经过多个处理者，这可能会导致⼀些性能问题，并且如果整个链上也没有合适的处理者来
处理请求，就会导致请求⽆法被处理。  
责任链模式是设计模式中简单且常⻅的设计模式，在⽇常中也会经常使⽤到，⽐如Java开发中过滤器的链式处理，
以及Spring框架中的拦截器，都组装成⼀个处理链对请求、响应进⾏处理。

## 解释器模式
解释器模式（Interpreter Pattern）是⼀种⾏为型设计模式，它定义了⼀个语⾔的⽂法，并且建⽴⼀个【解释器】
来解释该语⾔中的句⼦。  
⽐如说SQL语法、正则表达式，这些内容⽐较简短，但是表达的内容可不仅仅是字⾯上的那些符号，计算机想要理
解这些语法，就需要解释这个语法规则，因此解释器模式常⽤于实现编程语⾔解释器、正则表达式处理等场景。

解释器模式主要包含以下⼏个⻆⾊：
1. 抽象表达式（Abstract Expression）： 定义了解释器的接⼝，包含了解释器的⽅法 interpret 。
2. 终结符表达式（Terminal Expression）： 在语法中不能再分解为更⼩单元的符号。
3. ⾮终结符表达式（Non-terminal Expression）： ⽂法中的复杂表达式，它由终结符和其他⾮终结符组成。
4. 上下⽂（Context）： 包含解释器之外的⼀些全局信息，可以存储解释器中间结果，也可以⽤于向解释器传
   递信息。

当需要解释和执⾏特定领域或业务规则的语⾔时，可以使⽤解释器模式。例如，SQL解释器、正则表达式解释器
等。但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使⽤要慎重。

## 访问者模式
访问者模式（Visitor Pattern）是⼀种⾏为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进⾏新
的操作。  
举个例⼦，假设有⼀个动物园，⾥⾯有不同种类的动物，⽐如狮⼦、⼤象、猴⼦等。每个动物都会被医⽣检查身
体，被管理员投喂，被游客观看，医⽣，游客，管理员都属于访问者。

访问者模式结构较为复杂，但是访问者模式将同⼀类操作封装在⼀个访问者中，使得相关的操作彼此集中，提⾼了
代码的可读性和维护性。它常⽤于对象结构⽐较稳定，但经常需要在此对象结构上定义新的操作，这样就⽆需修改
现有的元素类，只需要定义新的访问者来添加新的操作。